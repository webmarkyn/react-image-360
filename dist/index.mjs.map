{"version":3,"sources":["../src/ReactImageTurntable.tsx","../src/hooks.ts"],"sourcesContent":["import React, { useEffect } from 'react';\nimport type { CSSProperties, FC, MouseEvent } from 'react';\n\nimport { useTurntableState } from './hooks';\nimport type { ReactImageTurntableFullProps } from './types';\n\n/** Base `className` for images. */\nexport const CLASS_NAME_IMG = '__react-image-turntable-img';\n/** `className` of first rendered image (sets the size of the main component). */\nexport const CLASS_NAME_IMG_PRIMARY = `${CLASS_NAME_IMG}--primary`;\n/** `className` of subsequent images. */\nexport const CLASS_NAME_IMG_SECONDARY = `${CLASS_NAME_IMG}--secondary`;\n\nconst imgBaseStyle = {\n  maxWidth: '100%',\n};\n\n/**\n * Firefox desktop tries to drag the image on `mousedown` + `mousemove` so we need to prevent it\n * then mimic the default behavior of the browser.\n */\nconst handleImgDragStart = (ev: MouseEvent<HTMLImageElement>) => {\n  ev.preventDefault();\n};\n\nexport const ReactImageTurntable: FC<ReactImageTurntableFullProps> = ({\n  images,\n  initialImageIndex = 0,\n  style,\n  tabIndex = 0,\n  movementSensitivity = 20,\n  onIndexChange,\n  autoRotate = { disabled: false },\n  ...props\n}) => {\n  const { ref, activeImageIndex } = useTurntableState({\n    initialImageIndex,\n    imagesCount: images.length - 1,\n    movementSensitivity,\n    autoRotate,\n  });\n\n  const rootStyle: CSSProperties = {\n    position: 'relative',\n    touchAction: 'none',\n    userSelect: 'none',\n    ...style,\n  };\n\n  useEffect(() => {\n    if (onIndexChange) onIndexChange(activeImageIndex);\n  }, [activeImageIndex, onIndexChange]);\n\n  return (\n    <div\n      aria-label=\"Image turntable\"\n      {...props}\n      ref={ref}\n      role=\"slider\"\n      aria-valuemin={1}\n      aria-valuemax={images.length}\n      aria-valuenow={activeImageIndex + 1}\n      aria-valuetext={`${activeImageIndex + 1} of ${images.length}`}\n      style={rootStyle}\n      tabIndex={tabIndex}\n    >\n      {images.map((src, index) => (\n        <img\n          key={src}\n          className={`${CLASS_NAME_IMG} ${\n            index === 0 ? CLASS_NAME_IMG_PRIMARY : CLASS_NAME_IMG_SECONDARY\n          }`}\n          src={src}\n          alt={`Turntable image ${index + 1}`}\n          draggable={false}\n          onDragStart={handleImgDragStart}\n          style={{\n            ...imgBaseStyle,\n            position: index === 0 ? undefined : 'absolute',\n            opacity: index === activeImageIndex ? 1 : 0,\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            objectFit: 'cover',\n          }}\n        />\n      ))}\n    </div>\n  );\n};\n","import { useEffect, useRef, useState } from 'react';\n\nimport type { ReactImageTurntableProps } from './types';\n\ninterface UseTurntableStateProps\n  extends Required<\n    Pick<ReactImageTurntableProps, 'initialImageIndex' | 'movementSensitivity' | 'autoRotate'>\n  > {\n  /** Number of images starting from zero. */\n  imagesCount: number;\n}\n\nexport const useTurntableState = ({\n  initialImageIndex,\n  imagesCount,\n  movementSensitivity,\n  autoRotate,\n}: UseTurntableStateProps) => {\n  const [activeImageIndex, setActiveImageIndex] = useState(initialImageIndex);\n  const intervalIdRef = useRef<NodeJS.Timeout | null>(null);\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    setActiveImageIndex(initialImageIndex);\n  }, [initialImageIndex]);\n\n  const clearAutoRotateInterval = () => {\n    if (intervalIdRef.current) {\n      clearInterval(intervalIdRef.current);\n      intervalIdRef.current = null;\n    }\n  };\n\n  useEffect(() => {\n    if (!autoRotate.disabled && !intervalIdRef.current) {\n      intervalIdRef.current = setInterval(() => {\n        setActiveImageIndex((prevIndex) => {\n          const nextIndex = prevIndex + 1;\n          return nextIndex > imagesCount ? 0 : nextIndex;\n        });\n      }, autoRotate.interval || 200);\n    }\n    if (autoRotate.disabled) clearAutoRotateInterval();\n\n    return () => clearAutoRotateInterval();\n  }, [autoRotate, imagesCount]);\n\n  useEffect(() => {\n    const target = ref.current as HTMLDivElement;\n    let prevDragPosition = 0;\n\n    const incrementActiveIndex = () => {\n      setActiveImageIndex((prev) => (prev + 1 > imagesCount ? 0 : prev + 1));\n    };\n\n    const decrementActiveIndex = () => {\n      setActiveImageIndex((prev) => (prev - 1 < 0 ? imagesCount : prev - 1));\n    };\n\n    const handleKeyDown = (ev: KeyboardEvent) => {\n      if (ev.key === 'ArrowLeft') {\n        decrementActiveIndex();\n      } else if (ev.key === 'ArrowRight') {\n        incrementActiveIndex();\n      }\n    };\n\n    const handlePointerMove = (ev: PointerEvent) => {\n      const distanceDragged = prevDragPosition - ev.clientX;\n\n      if (distanceDragged <= -movementSensitivity) {\n        prevDragPosition = prevDragPosition + movementSensitivity;\n        incrementActiveIndex();\n      }\n\n      if (distanceDragged >= movementSensitivity) {\n        prevDragPosition = prevDragPosition - movementSensitivity;\n        decrementActiveIndex();\n      }\n    };\n\n    const handlePointerUp = () => {\n      window.removeEventListener('pointermove', handlePointerMove);\n      window.removeEventListener('pointerup', handlePointerUp);\n    };\n\n    const handlePointerDown = (ev: PointerEvent) => {\n      if (ev.button == 2) {\n        return;\n      }\n\n      prevDragPosition = ev.clientX;\n      window.addEventListener('pointermove', handlePointerMove, { passive: true });\n      window.addEventListener('pointerup', handlePointerUp, { passive: true });\n    };\n\n    target.addEventListener('keydown', handleKeyDown, { capture: true });\n    target.addEventListener('pointerdown', handlePointerDown, { capture: true });\n\n    return () => {\n      target.removeEventListener('keydown', handleKeyDown, { capture: true });\n      target.removeEventListener('pointerdown', handlePointerDown, { capture: true });\n      window.removeEventListener('pointerup', handlePointerUp);\n      window.removeEventListener('pointermove', handlePointerMove);\n    };\n  }, [imagesCount, movementSensitivity]);\n\n  return {\n    ref,\n    activeImageIndex,\n  };\n};\n"],"mappings":"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","names":["useEffect","useEffect","useRef","useState","useTurntableState","initialImageIndex","imagesCount","movementSensitivity","autoRotate","activeImageIndex","setActiveImageIndex","intervalIdRef","ref","clearAutoRotateInterval","prevIndex","nextIndex","target","prevDragPosition","incrementActiveIndex","prev","decrementActiveIndex","handleKeyDown","ev","handlePointerMove","distanceDragged","handlePointerUp","handlePointerDown","jsx","CLASS_NAME_IMG","CLASS_NAME_IMG_PRIMARY","CLASS_NAME_IMG_SECONDARY","imgBaseStyle","handleImgDragStart","ev","ReactImageTurntable","images","initialImageIndex","style","tabIndex","movementSensitivity","onIndexChange","autoRotate","props","ref","activeImageIndex","useTurntableState","rootStyle","useEffect","src","index"]}